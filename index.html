<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Multiplayer Tetris Challenge</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap');
    
    :root {
      --primary-color: #FF6B6B;
      --secondary-color: #4ECDC4;
      --accent-color: #FFE66D;
      --dark-color: #292F36;
      --light-color: #F7FFF7;
      --player1-color: #FF6B6B;
      --player2-color: #4ECDC4;
      --shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      --transition: all 0.3s ease;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      margin: 0;
      background: linear-gradient(135deg, #292F36, #1A1E23);
      font-family: 'Poppins', sans-serif;
      color: var(--light-color);
      overflow-x: hidden;
      touch-action: manipulation;
    }

    #game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
      padding: 20px;
      background: rgba(41, 47, 54, 0.8);
      border-radius: 16px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(8px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      max-width: 100%;
      box-sizing: border-box;
      position: relative;
    }

    .game-title {
      font-size: 2rem;
      font-weight: 700;
      color: var(--accent-color);
      margin-bottom: 10px;
      text-align: center;
    }

    .multiplayer-section {
      background: rgba(255,255,255,0.15);
      border-radius: 12px;
      padding: 15px;
      margin-bottom: 20px;
      text-align: center;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
      border: 1px solid rgba(255,255,255,0.1);
      width: 100%;
    }

    .connection-status {
      display: inline-block;
      padding: 5px 10px;
      border-radius: 20px;
      font-size: 0.9rem;
      margin: 5px 0;
    }

    .status-connected {
      background: rgba(46, 204, 113, 0.3);
      color: #2ecc71;
      border: 1px solid #2ecc71;
    }

    .status-disconnected {
      background: rgba(231, 76, 60, 0.3);
      color: #e74c3c;
      border: 1px solid #e74c3c;
    }

    .status-connecting {
      background: rgba(241, 196, 15, 0.3);
      color: #f1c40f;
      border: 1px solid #f1c40f;
    }

    .players-container {
      display: flex;
      justify-content: space-between;
      width: 100%;
      gap: 20px;
    }

    .player-area {
      display: flex;
      flex-direction: column;
      align-items: center;
      flex: 1;
    }

    .player-header {
      display: flex;
      justify-content: space-between;
      width: 100%;
      margin-bottom: 10px;
    }

    .player-info {
      display: flex;
      flex-direction: column;
      align-items: center;
      background: rgba(0, 0, 0, 0.3);
      padding: 10px 15px;
      border-radius: 10px;
      min-width: 120px;
    }

    .player1 .player-info {
      border: 2px solid var(--player1-color);
    }

    .player2 .player-info {
      border: 2px solid var(--player2-color);
    }

    .player-label {
      font-size: 0.9rem;
      font-weight: 500;
      margin-bottom: 5px;
    }

    .player1 .player-label {
      color: var(--player1-color);
    }

    .player2 .player-label {
      color: var(--player2-color);
    }

    .player-value {
      font-size: 1.5rem;
      font-weight: 700;
    }

    #game-area {
      display: flex;
      gap: 20px;
      align-items: flex-start;
      justify-content: center;
      width: 100%;
    }

    .game-board-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }

    .game-board {
      display: grid;
      grid-template-columns: repeat(10, min(3.5vw, 25px));
      grid-template-rows: repeat(20, min(3.5vw, 25px));
      gap: 1px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      padding: 8px;
      box-shadow: var(--shadow);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .player1 .game-board {
      border: 2px solid var(--player1-color);
    }

    .player2 .game-board {
      border: 2px solid var(--player2-color);
    }

    .side-panel {
      display: flex;
      flex-direction: column;
      gap: 20px;
      min-width: min(16vw, 120px);
    }

    .panel-box {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }

    .panel-label {
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--accent-color);
      text-align: center;
    }

    .hold-board, .next-board {
      display: grid;
      grid-template-columns: repeat(4, min(4vw, 25px));
      grid-template-rows: repeat(4, min(4vw, 25px));
      gap: 1px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      padding: 8px;
      box-shadow: var(--shadow);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .cell {
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 2px;
      transition: var(--transition);
    }

    .tetromino {
      border: 1px solid rgba(255, 255, 255, 0.9);
      background-clip: padding-box;
      border-radius: 4px;
      box-shadow: inset 0 0 8px rgba(255, 255, 255, 0.3);
    }

    .ghost {
      border: 1px dashed rgba(255, 255, 255, 0.7);
      background: rgba(255, 255, 255, 0.1);
      opacity: 0.8;
      border-radius: 4px;
    }

    /* Tetromino colors */
    .I { background: #00C2D1; }
    .J { background: #FF6B6B; }
    .L { background: #FFA630; }
    .O { background: #FFE66D; }
    .S { background: #4ECDC4; }
    .T { background: #9D6BFF; }
    .Z { background: #FF85A1; }

    #controls {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
      width: 100%;
      margin-top: 10px;
    }

    button {
      padding: 12px 0;
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--dark-color);
      background: var(--accent-color);
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: var(--transition);
      box-shadow: var(--shadow);
      user-select: none;
    }

    button:active {
      transform: scale(0.95);
    }

    button:hover {
      background: #FFD700;
      transform: translateY(-2px);
    }

    button.secondary {
      background: var(--secondary-color);
      color: white;
    }

    button.secondary:hover {
      background: #3DBEB6;
    }

    button.danger {
      background: var(--primary-color);
      color: white;
    }

    button.danger:hover {
      background: #FF5252;
    }

    #game-over {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.9);
      justify-content: center;
      align-items: center;
      flex-direction: column;
      color: white;
      font-size: 2rem;
      font-weight: 700;
      text-align: center;
      z-index: 1000;
      backdrop-filter: blur(5px);
      animation: fadeIn 0.5s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    #game-over h2 {
      color: var(--accent-color);
      margin-bottom: 20px;
      font-size: 3rem;
    }

    #winner {
      color: var(--secondary-color);
      font-size: 2.5rem;
      margin: 10px 0;
    }

    .restart-btn {
      margin-top: 30px;
      background: var(--primary-color);
      color: white;
      padding: 15px 30px;
      font-size: 1.2rem;
      border-radius: 50px;
      box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
    }

    .restart-btn:hover {
      background: #FF5252;
      transform: translateY(-3px) scale(1.05);
    }

    #pause-screen {
      display: none;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      border-radius: 16px;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      color: white;
      z-index: 100;
    }

    #pause-screen h2 {
      color: var(--accent-color);
      font-size: 2.5rem;
      margin-bottom: 20px;
    }

    .mobile-controls {
      display: none;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      width: 100%;
      margin-top: 15px;
    }

    .mobile-btn {
      height: 60px;
      font-size: 1.5rem;
    }

    .mobile-btn.rotate {
      grid-column: span 3;
    }

    .how-to-play {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.5);
      color: white;
      border: none;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      font-size: 1.2rem;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 10;
    }

    #instructions {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.9);
      justify-content: center;
      align-items: center;
      flex-direction: column;
      color: white;
      z-index: 2000;
      padding: 20px;
      text-align: center;
    }

    #instructions h2 {
      color: var(--accent-color);
      margin-bottom: 20px;
    }

    #instructions ul {
      text-align: left;
      max-width: 500px;
      margin: 20px auto;
      line-height: 1.6;
    }

    #instructions li {
      margin-bottom: 10px;
    }

    .close-btn {
      margin-top: 30px;
      background: var(--secondary-color);
      color: white;
      padding: 10px 25px;
      border-radius: 50px;
    }

    .player-controls {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 15px;
    }

    .player-controls h3 {
      font-size: 1rem;
      color: var(--accent-color);
      text-align: center;
    }

    .player-status {
      text-align: center;
      font-size: 0.9rem;
      margin-bottom: 5px;
      color: #ecf0f1;
    }

    .game-actions {
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-items: center;
      margin: 20px 0;
    }

    .garbage-line {
      background: rgba(255, 255, 255, 0.2);
      border: 1px dashed rgba(255, 255, 255, 0.5);
    }

    @media (max-width: 1024px) {
      .players-container {
        flex-direction: column;
      }
      
      .game-board {
        grid-template-columns: repeat(10, min(4vw, 25px));
        grid-template-rows: repeat(20, min(4vw, 25px));
      }
      
      .hold-board, .next-board {
        grid-template-columns: repeat(4, min(4vw, 25px));
        grid-template-rows: repeat(4, min(4vw, 25px));
      }
    }

    @media (max-width: 768px) {
      #game-area {
        flex-direction: column;
        align-items: center;
      }
      
      .side-panel {
        flex-direction: row;
        width: 100%;
        justify-content: space-around;
      }
      
      #controls {
        display: none;
      }
      
      .mobile-controls {
        display: grid;
      }
      
      .game-header {
        flex-direction: column;
        gap: 10px;
        align-items: center;
      }
    }

    @media (max-height: 700px) {
      .game-board {
        grid-template-columns: repeat(10, min(3.5vh, 25px));
        grid-template-rows: repeat(20, min(3.5vh, 25px));
      }
      
      .hold-board, .next-board {
        grid-template-columns: repeat(4, min(3.5vh, 25px));
        grid-template-rows: repeat(4, min(3.5vh, 25px));
      }
    }

    /* Animations */
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }

    .pulse {
      animation: pulse 0.5s ease;
    }

    .clear-row {
      animation: clearAnimation 0.3s ease-out;
    }

    @keyframes clearAnimation {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.1); opacity: 0.8; }
      100% { transform: scale(0); opacity: 0; }
    }
  </style>
</head>
<body>
  <div id="game-container">
    <button class="how-to-play" onclick="showInstructions()">?</button>
    
    <h1 class="game-title">Multiplayer Tetris Challenge</h1>
    
    <div class="multiplayer-section">
      <div class="mb-3">
        <div class="connection-status" id="connection-status">Disconnected</div>
      </div>
      <div class="row" style="display: flex; flex-wrap: wrap; gap: 10px; justify-content: center;">
        <div>
          <button class="btn btn-primary w-100 mb-2" id="host-game" style="background: var(--secondary-color); color: white; border: none; padding: 10px 20px; border-radius: 8px;">Host Game</button>
          <div id="host-info" style="display: none;">
            <p class="mb-1">Share this ID:</p>
            <h4 id="host-id" class="text-warning" style="color: var(--accent-color);"></h4>
          </div>
        </div>
        <div>
          <div class="input-group mb-2" style="display: flex;">
            <input type="text" class="form-control" id="join-id" placeholder="Enter Host ID" style="border-radius: 8px 0 0 8px; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.1); color: white;">
            <button class="btn btn-outline-secondary" id="join-game" style="border-radius: 0 8px 8px 0; border: 1px solid var(--accent-color); color: var(--accent-color); background: transparent;">Join Game</button>
          </div>
        </div>
      </div>
      <button class="btn btn-primary" id="start-game" style="background: var(--primary-color); color: white; border: none; padding: 10px 20px; border-radius: 8px; margin-top: 10px; display: none;">Start Game</button>
    </div>
    
    <div class="players-container" style="display: none;" id="game-players">
      <!-- Player 1 -->
      <div class="player-area player1">
        <div class="player-header">
          <div class="player-info">
            <div class="player-label">PLAYER 1</div>
            <div id="player1-score" class="player-value">0</div>
          </div>
          <div class="player-info">
            <div class="player-label">LEVEL</div>
            <div id="player1-level" class="player-value">1</div>
          </div>
          <div class="player-info">
            <div class="player-label">LINES</div>
            <div id="player1-lines" class="player-value">0</div>
          </div>
        </div>
        
        <div id="game-area">
          <div class="game-board-container">
            <div id="player1-board" class="game-board"></div>
          </div>
          <div class="side-panel">
            <div class="panel-box">
              <div class="panel-label">HOLD</div>
              <div id="player1-hold-board" class="hold-board"></div>
            </div>
            <div class="panel-box">
              <div class="panel-label">NEXT</div>
              <div id="player1-next-board" class="next-board"></div>
            </div>
          </div>
        </div>
        
        <div class="player-controls">
          <h3>Player 1 Controls</h3>
          <div class="mobile-controls">
            <button onclick="movePiece(0, -1, 0)" class="mobile-btn secondary">←</button>
            <button onclick="movePiece(0, 0, 1)" class="mobile-btn">↓</button>
            <button onclick="movePiece(0, 1, 0)" class="mobile-btn secondary">→</button>
            <button onclick="rotatePiece(0)" class="mobile-btn rotate secondary">ROTATE</button>
            <button onclick="dropPiece(0)" class="mobile-btn danger">DROP</button>
            <button onclick="storePiece(0)" class="mobile-btn secondary">HOLD</button>
          </div>
        </div>
      </div>
      
      <!-- Player 2 -->
      <div class="player-area player2">
        <div class="player-header">
          <div class="player-info">
            <div class="player-label">PLAYER 2</div>
            <div id="player2-score" class="player-value">0</div>
          </div>
          <div class="player-info">
            <div class="player-label">LEVEL</div>
            <div id="player2-level" class="player-value">1</div>
          </div>
          <div class="player-info">
            <div class="player-label">LINES</div>
            <div id="player2-lines" class="player-value">0</div>
          </div>
        </div>
        
        <div id="game-area">
          <div class="game-board-container">
            <div id="player2-board" class="game-board"></div>
          </div>
          <div class="side-panel">
            <div class="panel-box">
              <div class="panel-label">HOLD</div>
              <div id="player2-hold-board" class="hold-board"></div>
            </div>
            <div class="panel-box">
              <div class="panel-label">NEXT</div>
              <div id="player2-next-board" class="next-board"></div>
            </div>
          </div>
        </div>
        
        <div class="player-controls">
          <h3>Player 2 Controls</h3>
          <div class="mobile-controls">
            <button onclick="movePiece(1, -1, 0)" class="mobile-btn secondary">←</button>
            <button onclick="movePiece(1, 0, 1)" class="mobile-btn">↓</button>
            <button onclick="movePiece(1, 1, 0)" class="mobile-btn secondary">→</button>
            <button onclick="rotatePiece(1)" class="mobile-btn rotate secondary">ROTATE</button>
            <button onclick="dropPiece(1)" class="mobile-btn danger">DROP</button>
            <button onclick="storePiece(1)" class="mobile-btn secondary">HOLD</button>
          </div>
        </div>
      </div>
    </div>
    
    <div id="controls" style="display: none;">
      <button onclick="togglePause()" class="secondary">PAUSE ⏸</button>
    </div>
    
    <div id="pause-screen">
      <h2>PAUSED</h2>
      <button onclick="togglePause()" class="restart-btn">RESUME</button>
    </div>
  </div>
  
  <div id="game-over">
    <h2>GAME OVER</h2>
    <div id="winner"></div>
    <button onclick="restartGame()" class="restart-btn">PLAY AGAIN</button>
  </div>
  
  <div id="instructions">
    <h2>HOW TO PLAY MULTIPLAYER TETRIS</h2>
    <h3>Player 1 Controls</h3>
    <ul>
      <li><strong>A/D</strong> Move piece left/right</li>
      <li><strong>S</strong> Soft drop (move down)</li>
      <li><strong>W</strong> Rotate piece</li>
      <li><strong>SPACE</strong> Hard drop</li>
      <li><strong>C</strong> Hold piece</li>
    </ul>
    <h3>Player 2 Controls</h3>
    <ul>
      <li><strong>← →</strong> Move piece left/right</li>
      <li><strong>↓</strong> Soft drop (move down)</li>
      <li><strong>↑</strong> Rotate piece</li>
      <li><strong>ENTER</strong> Hard drop</li>
      <li><strong>SHIFT</strong> Hold piece</li>
    </ul>
    <p>Complete lines to score points and send garbage lines to your opponent!</p>
    <button onclick="hideInstructions()" class="close-btn">GOT IT!</button>
  </div>

  <!-- Simple Peer library for WebRTC connections -->
  <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
  
  <script>
    // Game constants
    const BOARD_WIDTH = 10;
    const BOARD_HEIGHT = 20;
    const PLAYER_COUNT = 2;

    // Multiplayer State
    const multiplayerState = {
      peer: null,
      conn: null,
      isHost: false,
      isConnected: false,
      peerId: null,
      remotePlayer: null,
      gameStarted: false
    };

    // Game state for both players
    const players = [
      {
        board: Array.from({ length: BOARD_HEIGHT }, () => Array(BOARD_WIDTH).fill(0)),
        currentPiece: null,
        nextPiece: null,
        storedPiece: null,
        canStorePiece: true,
        score: 0,
        level: 1,
        lines: 0,
        dropInterval: 1000,
        lastTime: 0,
        isGameOver: false
      },
      {
        board: Array.from({ length: BOARD_HEIGHT }, () => Array(BOARD_WIDTH).fill(0)),
        currentPiece: null,
        nextPiece: null,
        storedPiece: null,
        canStorePiece: true,
        score: 0,
        level: 1,
        lines: 0,
        dropInterval: 1000,
        lastTime: 0,
        isGameOver: false
      }
    ];

    let isPaused = false;
    let animationFrameId;
    let garbageQueue = [0, 0]; // Garbage lines to be sent to each player

    const tetrominoes = [
      { shape: [[1, 1, 1, 1]], color: 'I' }, // I
      { shape: [[1, 1], [1, 1]], color: 'O' }, // O
      { shape: [[0, 1, 0], [1, 1, 1]], color: 'T' }, // T
      { shape: [[1, 1, 0], [0, 1, 1]], color: 'S' }, // S
      { shape: [[0, 1, 1], [1, 1, 0]], color: 'Z' }, // Z
      { shape: [[1, 0, 0], [1, 1, 1]], color: 'J' }, // J
      { shape: [[0, 0, 1], [1, 1, 1]], color: 'L' }  // L
    ];

    // DOM Elements
    const connectionStatusEl = document.getElementById('connection-status');
    const hostGameBtn = document.getElementById('host-game');
    const joinGameBtn = document.getElementById('join-game');
    const startGameBtn = document.getElementById('start-game');
    const hostInfoEl = document.getElementById('host-info');
    const hostIdEl = document.getElementById('host-id');
    const joinIdEl = document.getElementById('join-id');
    const gamePlayersEl = document.getElementById('game-players');
    const controlsEl = document.getElementById('controls');
    const gameOverEl = document.getElementById('game-over');
    const winnerEl = document.getElementById('winner');

    // Multiplayer Functions
    function initializeMultiplayer() {
      multiplayerState.peerId = 'tetris-' + Math.random().toString(36).substring(2, 9);
      multiplayerState.peer = new Peer(multiplayerState.peerId, {
        debug: 2,
        config: {
          iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:global.stun.twilio.com:3478' }
          ]
        }
      });

      multiplayerState.peer.on('open', (id) => {
        updateConnectionStatus('disconnected', 'Ready to connect');
        console.log(`Your ID: ${id}`);
      });

      multiplayerState.peer.on('connection', (conn) => {
        setupConnection(conn);
        multiplayerState.isHost = true;
        updateConnectionStatus('connected', 'Player connected!');
        startGameBtn.style.display = 'block';
        console.log('A Player has joined your game!');
      });

      multiplayerState.peer.on('error', (err) => {
        console.error('PeerJS error:', err);
        updateConnectionStatus('disconnected', 'Connection error');
      });
    }

    function setupConnection(conn) {
      multiplayerState.conn = conn;
      multiplayerState.isConnected = true;
      multiplayerState.remotePlayer = conn.peer;

      conn.on('open', () => {
        updateConnectionStatus('connected', 'Connected to player');
        if (multiplayerState.isHost) {
          sendGameState();
        }
      });

      conn.on('data', (data) => {
        handleIncomingData(data);
      });

      conn.on('close', () => {
        multiplayerState.isConnected = false;
        updateConnectionStatus('disconnected', 'Player disconnected');
        console.log('Other player disconnected');
      });

      conn.on('error', (err) => {
        console.error('Connection error:', err);
        updateConnectionStatus('disconnected', 'Connection error');
      });
    }

    function hostGame() {
      multiplayerState.isHost = true;
      hostInfoEl.style.display = 'block';
      hostIdEl.textContent = multiplayerState.peerId;
      updateConnectionStatus('connecting', 'Waiting for player...');
      console.log('You are now the Host! Share your ID: ' + multiplayerState.peerId);
    }

    function joinGame() {
      const hostId = joinIdEl.value.trim();
      if (!hostId) {
        alert('Please enter a host ID');
        return;
      }

      multiplayerState.isHost = false;
      const conn = multiplayerState.peer.connect(hostId);
      setupConnection(conn);
      updateConnectionStatus('connecting', 'Connecting to host...');
      console.log(`Connecting to Host ${hostId}...`);
    }

    function startGame() {
      if (!multiplayerState.isConnected) {
        alert('No player connected yet!');
        return;
      }

      multiplayerState.gameStarted = true;
      gamePlayersEl.style.display = 'flex';
      controlsEl.style.display = 'grid';
      startGameBtn.style.display = 'none';
      
      // Initialize game for both players
      players.forEach((player, index) => {
        player.currentPiece = createPiece();
        player.nextPiece = createPiece();
        drawNextBoard(index);
        drawBoard(index);
        player.lastTime = performance.now();
      });

      // Start game loop
      gameLoop(performance.now());

      // Send start game signal to client
      if (multiplayerState.isHost) {
        sendAction('startGame');
      }
    }

    function sendGameState() {
      if (!multiplayerState.isConnected) return;
      multiplayerState.conn.send({
        type: 'gameState',
        state: players,
        garbageQueue: garbageQueue
      });
    }

    function sendAction(action, data = {}) {
      if (!multiplayerState.isConnected) return;
      multiplayerState.conn.send({
        type: 'action',
        action: action,
        data: data,
        sender: multiplayerState.isHost ? 'host' : 'client'
      });
    }

    function handleIncomingData(data) {
      switch (data.type) {
        case 'gameState':
          if (!multiplayerState.isHost) {
            Object.assign(players, data.state);
            garbageQueue = data.garbageQueue || [0, 0];
            updateUI();
          }
          break;
        case 'action':
          handleRemoteAction(data.action, data.data, data.sender);
          break;
      }
    }

    function handleRemoteAction(action, data, sender) {
      switch (action) {
        case 'startGame':
          if (!multiplayerState.isHost) {
            multiplayerState.gameStarted = true;
            gamePlayersEl.style.display = 'flex';
            controlsEl.style.display = 'grid';
            startGameBtn.style.display = 'none';
            
            players.forEach((player, index) => {
              player.currentPiece = createPiece();
              player.nextPiece = createPiece();
              drawNextBoard(index);
              drawBoard(index);
              player.lastTime = performance.now();
            });
            
            gameLoop(performance.now());
          }
          break;
        case 'movePiece':
          if (multiplayerState.isHost) {
            movePiece(data.playerIndex, data.dx, data.dy);
            sendGameState();
          }
          break;
        case 'rotatePiece':
          if (multiplayerState.isHost) {
            rotatePiece(data.playerIndex);
            sendGameState();
          }
          break;
        case 'dropPiece':
          if (multiplayerState.isHost) {
            dropPiece(data.playerIndex);
            sendGameState();
          }
          break;
        case 'storePiece':
          if (multiplayerState.isHost) {
            storePiece(data.playerIndex);
            sendGameState();
          }
          break;
        case 'gameOver':
          endGame(data.winner);
          break;
      }
    }

    function updateConnectionStatus(status, message) {
      connectionStatusEl.textContent = message;
      connectionStatusEl.className = 'connection-status';
      switch (status) {
        case 'connected':
          connectionStatusEl.classList.add('status-connected');
          multiplayerState.isConnected = true;
          break;
        case 'disconnected':
          connectionStatusEl.classList.add('status-disconnected');
          multiplayerState.isConnected = false;
          break;
        case 'connecting':
          connectionStatusEl.classList.add('status-connecting');
          break;
      }
    }

    // Game Functions
    function createPiece() {
      const piece = tetrominoes[Math.floor(Math.random() * tetrominoes.length)];
      return {
        shape: piece.shape.map(row => [...row]),
        color: piece.color,
        x: Math.floor((BOARD_WIDTH - piece.shape[0].length) / 2),
        y: 0
      };
    }

    function getGhostPosition(playerIndex) {
      const player = players[playerIndex];
      const ghost = { ...player.currentPiece, y: player.currentPiece.y };
      
      while (!isCollision(playerIndex, ghost)) {
        ghost.y++;
      }
      ghost.y--;
      
      return ghost;
    }

    function drawBoard(playerIndex) {
      const boardElement = document.getElementById(`player${playerIndex + 1}-board`);
      boardElement.innerHTML = '';
      
      const player = players[playerIndex];
      const ghost = getGhostPosition(playerIndex);
      
      for (let y = 0; y < BOARD_HEIGHT; y++) {
        for (let x = 0; x < BOARD_WIDTH; x++) {
          const cell = document.createElement('div');
          cell.classList.add('cell');
          
          const isPlaced = player.board[y][x];
          const isCurrent = player.currentPiece && 
                           player.currentPiece.shape[y - player.currentPiece.y]?.[x - player.currentPiece.x];
          const isGhost = ghost && 
                         ghost.shape[y - ghost.y]?.[x - ghost.x];
          
          if (isPlaced) {
            cell.style.backgroundColor = getColor(isPlaced);
            cell.classList.add('tetromino');
            cell.classList.add(isPlaced);
          } else if (isGhost && !isCurrent) {
            cell.style.backgroundColor = getColor(player.currentPiece.color);
            cell.classList.add('ghost');
          } else if (isCurrent) {
            cell.style.backgroundColor = getColor(player.currentPiece.color);
            cell.classList.add('tetromino');
            cell.classList.add(player.currentPiece.color);
          }
          
          boardElement.appendChild(cell);
        }
      }
    }

    function getColor(type) {
      switch(type) {
        case 'I': return '#00C2D1';
        case 'J': return '#FF6B6B';
        case 'L': return '#FFA630';
        case 'O': return '#FFE66D';
        case 'S': return '#4ECDC4';
        case 'T': return '#9D6BFF';
        case 'Z': return '#FF85A1';
        default: return '#FFFFFF';
      }
    }

    function drawHoldBoard(playerIndex) {
      const holdBoard = document.getElementById(`player${playerIndex + 1}-hold-board`);
      holdBoard.innerHTML = '';
      
      const player = players[playerIndex];
      
      for (let y = 0; y < 4; y++) {
        for (let x = 0; x < 4; x++) {
          const cell = document.createElement('div');
          cell.classList.add('cell');
          
          if (player.storedPiece && player.storedPiece.shape[y]?.[x]) {
            cell.style.backgroundColor = getColor(player.storedPiece.color);
            cell.classList.add('tetromino');
            cell.classList.add(player.storedPiece.color);
          }
          
          holdBoard.appendChild(cell);
        }
      }
    }

    function drawNextBoard(playerIndex) {
      const nextBoard = document.getElementById(`player${playerIndex + 1}-next-board`);
      nextBoard.innerHTML = '';
      
      const player = players[playerIndex];
      
      for (let y = 0; y < 4; y++) {
        for (let x = 0; x < 4; x++) {
          const cell = document.createElement('div');
          cell.classList.add('cell');
          
          if (player.nextPiece.shape[y]?.[x]) {
            cell.style.backgroundColor = getColor(player.nextPiece.color);
            cell.classList.add('tetromino');
            cell.classList.add(player.nextPiece.color);
          }
          
          nextBoard.appendChild(cell);
        }
      }
    }

    function movePiece(playerIndex, dx, dy) {
      if (isPaused || players[playerIndex].isGameOver || !multiplayerState.gameStarted) return;
      
      const player = players[playerIndex];
      player.currentPiece.x += dx;
      player.currentPiece.y += dy;
      
      if (isCollision(playerIndex)) {
        player.currentPiece.x -= dx;
        player.currentPiece.y -= dy;
        
        if (dy === 1) {
          placePiece(playerIndex);
          clearLines(playerIndex);
          player.currentPiece = player.nextPiece;
          player.nextPiece = createPiece();
          player.canStorePiece = true;
          drawNextBoard(playerIndex);
          
          if (isCollision(playerIndex)) {
            player.isGameOver = true;
            checkGameOver();
          }
        }
      }
      
      drawBoard(playerIndex);
    }

    function rotatePiece(playerIndex) {
      if (isPaused || players[playerIndex].isGameOver || !multiplayerState.gameStarted) return;
      
      const player = players[playerIndex];
      const rotated = player.currentPiece.shape[0].map((_, i) =>
        player.currentPiece.shape.map(row => row[i]).reverse()
      );
      
      const originalShape = player.currentPiece.shape;
      player.currentPiece.shape = rotated;
      
      if (isCollision(playerIndex)) {
        player.currentPiece.shape = originalShape;
      }
      
      drawBoard(playerIndex);
    }

    function isCollision(playerIndex, piece = players[playerIndex].currentPiece) {
      const player = players[playerIndex];
      
      return piece.shape.some((row, y) =>
        row.some((value, x) => {
          const boardY = piece.y + y;
          const boardX = piece.x + x;
          
          return (value && (
            boardY >= BOARD_HEIGHT ||
            boardX < 0 ||
            boardX >= BOARD_WIDTH ||
            (boardY >= 0 && player.board[boardY][boardX])
          ));
        })
      );
    }

    function placePiece(playerIndex) {
      const player = players[playerIndex];
      
      player.currentPiece.shape.forEach((row, y) => {
        row.forEach((value, x) => {
          if (value) {
            const boardY = player.currentPiece.y + y;
            const boardX = player.currentPiece.x + x;
            
            if (boardY >= 0 && boardY < BOARD_HEIGHT && boardX >= 0 && boardX < BOARD_WIDTH) {
              player.board[boardY][boardX] = player.currentPiece.color;
            }
          }
        });
      });
    }

    function clearLines(playerIndex) {
      const player = players[playerIndex];
      let linesCleared = 0;
      
      for (let y = BOARD_HEIGHT - 1; y >= 0; y--) {
        if (player.board[y].every(cell => cell)) {
          player.board.splice(y, 1);
          player.board.unshift(Array(BOARD_WIDTH).fill(0));
          linesCleared++;
          y++;
        }
      }
      
      if (linesCleared > 0) {
        // Update score and level
        player.score += linesCleared * 100 * player.level;
        player.lines += linesCleared;
        
        document.getElementById(`player${playerIndex + 1}-score`).textContent = player.score;
        document.getElementById(`player${playerIndex + 1}-lines`).textContent = player.lines;
        
        // Level up every 10 lines
        if (player.lines >= player.level * 10) {
          player.level++;
          player.dropInterval = Math.max(100, 1000 - (player.level - 1) * 100);
          document.getElementById(`player${playerIndex + 1}-level`).textContent = player.level;
        }
        
        // Send garbage to opponent
        const opponentIndex = (playerIndex + 1) % PLAYER_COUNT;
        garbageQueue[opponentIndex] += linesCleared;
        
        // Add garbage lines to opponent
        if (garbageQueue[opponentIndex] > 0) {
          addGarbageLines(opponentIndex, garbageQueue[opponentIndex]);
          garbageQueue[opponentIndex] = 0;
        }
      }
    }

    function addGarbageLines(playerIndex, lines) {
      const player = players[playerIndex];
      
      for (let i = 0; i < lines; i++) {
        // Remove the top line
        player.board.shift();
        
        // Create a new garbage line with one hole
        const holePos = Math.floor(Math.random() * BOARD_WIDTH);
        const newLine = Array(BOARD_WIDTH).fill('G');
        newLine[holePos] = 0;
        
        // Add the garbage line at the bottom
        player.board.push(newLine);
      }
      
      drawBoard(playerIndex);
    }

    function dropPiece(playerIndex) {
      if (isPaused || players[playerIndex].isGameOver || !multiplayerState.gameStarted) return;
      
      const player = players[playerIndex];
      
      while (!isCollision(playerIndex)) {
        player.currentPiece.y++;
      }
      
      player.currentPiece.y--;
      placePiece(playerIndex);
      clearLines(playerIndex);
      player.currentPiece = player.nextPiece;
      player.nextPiece = createPiece();
      player.canStorePiece = true;
      drawNextBoard(playerIndex);
      
      if (isCollision(playerIndex)) {
        player.isGameOver = true;
        checkGameOver();
      }
      
      drawBoard(playerIndex);
    }

    function storePiece(playerIndex) {
      if (isPaused || players[playerIndex].isGameOver || !players[playerIndex].canStorePiece || !multiplayerState.gameStarted) return;
      
      const player = players[playerIndex];
      
      if (player.storedPiece) {
        const temp = player.storedPiece;
        player.storedPiece = { 
          shape: player.currentPiece.shape.map(row => [...row]), 
          color: player.currentPiece.color 
        };
        player.currentPiece = { 
          ...temp, 
          x: Math.floor((BOARD_WIDTH - temp.shape[0].length) / 2), 
          y: 0 
        };
      } else {
        player.storedPiece = { 
          shape: player.currentPiece.shape.map(row => [...row]), 
          color: player.currentPiece.color 
        };
        player.currentPiece = player.nextPiece;
        player.nextPiece = createPiece();
        drawNextBoard(playerIndex);
      }
      
      player.canStorePiece = false;
      drawHoldBoard(playerIndex);
      drawBoard(playerIndex);
    }

    function togglePause() {
      isPaused = !isPaused;
      
      if (!isPaused) {
        players.forEach((player, index) => {
          player.lastTime = performance.now();
        });
        gameLoop(performance.now());
      }
    }

    function checkGameOver() {
      const gameOverCount = players.filter(player => player.isGameOver).length;
      
      if (gameOverCount === PLAYER_COUNT) {
        endGame("It's a tie!");
      } else if (players[0].isGameOver) {
        endGame("Player 2 Wins!");
      } else if (players[1].isGameOver) {
        endGame("Player 1 Wins!");
      }
    }

    function endGame(winnerText) {
      cancelAnimationFrame(animationFrameId);
      winnerEl.textContent = winnerText;
      gameOverEl.style.display = 'flex';
      
      if (multiplayerState.isHost) {
        sendAction('gameOver', { winner: winnerText });
      }
    }

    function restartGame() {
      players.forEach((player, index) => {
        player.board = Array.from({ length: BOARD_HEIGHT }, () => Array(BOARD_WIDTH).fill(0));
        player.score = 0;
        player.level = 1;
        player.lines = 0;
        player.storedPiece = null;
        player.canStorePiece = true;
        player.isGameOver = false;
        player.dropInterval = 1000;
        
        document.getElementById(`player${index + 1}-score`).textContent = player.score;
        document.getElementById(`player${index + 1}-level`).textContent = player.level;
        document.getElementById(`player${index + 1}-lines`).textContent = player.lines;
        
        drawHoldBoard(index);
        
        player.currentPiece = createPiece();
        player.nextPiece = createPiece();
        
        drawNextBoard(index);
        drawBoard(index);
      });
      
      garbageQueue = [0, 0];
      isPaused = false;
      gameOverEl.style.display = 'none';
      
      players.forEach((player, index) => {
        player.lastTime = performance.now();
      });
      
      gameLoop(performance.now());
      
      if (multiplayerState.isHost) {
        sendGameState();
      }
    }

    function gameLoop(time) {
      if (isPaused || !multiplayerState.gameStarted) return;
      
      players.forEach((player, index) => {
        if (!player.isGameOver) {
          const delta = time - player.lastTime;
          
          if (delta >= player.dropInterval) {
            movePiece(index, 0, 1);
            player.lastTime = time - (delta % player.dropInterval);
            
            if (multiplayerState.isHost) {
              sendGameState();
            }
          }
        }
      });
      
      animationFrameId = requestAnimationFrame(gameLoop);
    }

    function updateUI() {
      players.forEach((player, index) => {
        document.getElementById(`player${index + 1}-score`).textContent = player.score;
        document.getElementById(`player${index + 1}-level`).textContent = player.level;
        document.getElementById(`player${index + 1}-lines`).textContent = player.lines;
      });
    }

    function showInstructions() {
      document.getElementById('instructions').style.display = 'flex';
    }

    function hideInstructions() {
      document.getElementById('instructions').style.display = 'none';
    }

    // Keyboard controls
    document.addEventListener('keydown', (e) => {
      if (!multiplayerState.gameStarted) return;
      
      if (e.key === 'p' || e.key === 'P') {
        togglePause();
        return;
      }
      
      // Player 1 controls (WASD + Space + C)
      if (multiplayerState.isHost) {
        if (e.key === 'a' || e.key === 'A') {
          movePiece(0, -1, 0);
          sendAction('movePiece', { playerIndex: 0, dx: -1, dy: 0 });
        }
        if (e.key === 'd' || e.key === 'D') {
          movePiece(0, 1, 0);
          sendAction('movePiece', { playerIndex: 0, dx: 1, dy: 0 });
        }
        if (e.key === 's' || e.key === 'S') {
          movePiece(0, 0, 1);
          sendAction('movePiece', { playerIndex: 0, dx: 0, dy: 1 });
        }
        if (e.key === 'w' || e.key === 'W') {
          rotatePiece(0);
          sendAction('rotatePiece', { playerIndex: 0 });
        }
        if (e.key === ' ') {
          dropPiece(0);
          sendAction('dropPiece', { playerIndex: 0 });
        }
        if (e.key === 'c' || e.key === 'C') {
          storePiece(0);
          sendAction('storePiece', { playerIndex: 0 });
        }
      } else {
        // Player 2 controls (Arrow keys + Enter + Shift)
        if (e.key === 'ArrowLeft') {
          movePiece(1, -1, 0);
          sendAction('movePiece', { playerIndex: 1, dx: -1, dy: 0 });
        }
        if (e.key === 'ArrowRight') {
          movePiece(1, 1, 0);
          sendAction('movePiece', { playerIndex: 1, dx: 1, dy: 0 });
        }
        if (e.key === 'ArrowDown') {
          movePiece(1, 0, 1);
          sendAction('movePiece', { playerIndex: 1, dx: 0, dy: 1 });
        }
        if (e.key === 'ArrowUp') {
          rotatePiece(1);
          sendAction('rotatePiece', { playerIndex: 1 });
        }
        if (e.key === 'Enter') {
          dropPiece(1);
          sendAction('dropPiece', { playerIndex: 1 });
        }
        if (e.key === 'Shift') {
          storePiece(1);
          sendAction('storePiece', { playerIndex: 1 });
        }
      }
    });

    // Initialize the game
    function init() {
      initializeMultiplayer();
      
      // Set up event listeners
      hostGameBtn.addEventListener('click', hostGame);
      joinGameBtn.addEventListener('click', joinGame);
      startGameBtn.addEventListener('click', startGame);
    }

    // Start the game
    init();
  </script>
</body>
</html>
