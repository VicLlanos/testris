<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>2-Player Tetris Challenge</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap');
    
    :root {
      --primary-color: #FF6B6B;
      --secondary-color: #4ECDC4;
      --accent-color: #FFE66D;
      --dark-color: #292F36;
      --light-color: #F7FFF7;
      --player1-color: #FF6B6B;
      --player2-color: #4ECDC4;
      --shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      --transition: all 0.3s ease;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      margin: 0;
      background: linear-gradient(135deg, #292F36, #1A1E23);
      font-family: 'Poppins', sans-serif;
      color: var(--light-color);
      overflow-x: hidden;
      touch-action: manipulation;
    }

    #game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
      padding: 20px;
      background: rgba(41, 47, 54, 0.8);
      border-radius: 16px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(8px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      max-width: 100%;
      box-sizing: border-box;
      position: relative;
    }

    .game-title {
      font-size: 2rem;
      font-weight: 700;
      color: var(--accent-color);
      margin-bottom: 10px;
      text-align: center;
    }

    .players-container {
      display: flex;
      justify-content: space-between;
      width: 100%;
      gap: 20px;
    }

    .player-area {
      display: flex;
      flex-direction: column;
      align-items: center;
      flex: 1;
    }

    .player-header {
      display: flex;
      justify-content: space-between;
      width: 100%;
      margin-bottom: 10px;
    }

    .player-info {
      display: flex;
      flex-direction: column;
      align-items: center;
      background: rgba(0, 0, 0, 0.3);
      padding: 10px 15px;
      border-radius: 10px;
      min-width: 120px;
    }

    .player1 .player-info {
      border: 2px solid var(--player1-color);
    }

    .player2 .player-info {
      border: 2px solid var(--player2-color);
    }

    .player-label {
      font-size: 0.9rem;
      font-weight: 500;
      margin-bottom: 5px;
    }

    .player1 .player-label {
      color: var(--player1-color);
    }

    .player2 .player-label {
      color: var(--player2-color);
    }

    .player-value {
      font-size: 1.5rem;
      font-weight: 700;
    }

    #game-area {
      display: flex;
      gap: 20px;
      align-items: flex-start;
      justify-content: center;
      width: 100%;
    }

    .game-board-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }

    .game-board {
      display: grid;
      grid-template-columns: repeat(10, min(3.5vw, 25px));
      grid-template-rows: repeat(20, min(3.5vw, 25px));
      gap: 1px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      padding: 8px;
      box-shadow: var(--shadow);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .player1 .game-board {
      border: 2px solid var(--player1-color);
    }

    .player2 .game-board {
      border: 2px solid var(--player2-color);
    }

    .side-panel {
      display: flex;
      flex-direction: column;
      gap: 20px;
      min-width: min(16vw, 120px);
    }

    .panel-box {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }

    .panel-label {
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--accent-color);
      text-align: center;
    }

    .hold-board, .next-board {
      display: grid;
      grid-template-columns: repeat(4, min(4vw, 25px));
      grid-template-rows: repeat(4, min(4vw, 25px));
      gap: 1px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      padding: 8px;
      box-shadow: var(--shadow);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .cell {
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 2px;
      transition: var(--transition);
    }

    .tetromino {
      border: 1px solid rgba(255, 255, 255, 0.9);
      background-clip: padding-box;
      border-radius: 4px;
      box-shadow: inset 0 0 8px rgba(255, 255, 255, 0.3);
    }

    .ghost {
      border: 1px dashed rgba(255, 255, 255, 0.7);
      background: rgba(255, 255, 255, 0.1);
      opacity: 0.8;
      border-radius: 4px;
    }

    /* Tetromino colors */
    .I { background: #00C2D1; }
    .J { background: #FF6B6B; }
    .L { background: #FFA630; }
    .O { background: #FFE66D; }
    .S { background: #4ECDC4; }
    .T { background: #9D6BFF; }
    .Z { background: #FF85A1; }

    #controls {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
      width: 100%;
      margin-top: 10px;
    }

    button {
      padding: 12px 0;
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--dark-color);
      background: var(--accent-color);
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: var(--transition);
      box-shadow: var(--shadow);
      user-select: none;
    }

    button:active {
      transform: scale(0.95);
    }

    button:hover {
      background: #FFD700;
      transform: translateY(-2px);
    }

    button.secondary {
      background: var(--secondary-color);
      color: white;
    }

    button.secondary:hover {
      background: #3DBEB6;
    }

    button.danger {
      background: var(--primary-color);
      color: white;
    }

    button.danger:hover {
      background: #FF5252;
    }

    #game-over {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.9);
      justify-content: center;
      align-items: center;
      flex-direction: column;
      color: white;
      font-size: 2rem;
      font-weight: 700;
      text-align: center;
      z-index: 1000;
      backdrop-filter: blur(5px);
      animation: fadeIn 0.5s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    #game-over h2 {
      color: var(--accent-color);
      margin-bottom: 20px;
      font-size: 3rem;
    }

    #winner {
      color: var(--secondary-color);
      font-size: 2.5rem;
      margin: 10px 0;
    }

    .restart-btn {
      margin-top: 30px;
      background: var(--primary-color);
      color: white;
      padding: 15px 30px;
      font-size: 1.2rem;
      border-radius: 50px;
      box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
    }

    .restart-btn:hover {
      background: #FF5252;
      transform: translateY(-3px) scale(1.05);
    }

    #pause-screen {
      display: none;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      border-radius: 16px;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      color: white;
      z-index: 100;
    }

    #pause-screen h2 {
      color: var(--accent-color);
      font-size: 2.5rem;
      margin-bottom: 20px;
    }

    .mobile-controls {
      display: none;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      width: 100%;
      margin-top: 15px;
    }

    .mobile-btn {
      height: 60px;
      font-size: 1.5rem;
    }

    .mobile-btn.rotate {
      grid-column: span 3;
    }

    .how-to-play {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.5);
      color: white;
      border: none;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      font-size: 1.2rem;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 10;
    }

    #instructions {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.9);
      justify-content: center;
      align-items: center;
      flex-direction: column;
      color: white;
      z-index: 2000;
      padding: 20px;
      text-align: center;
    }

    #instructions h2 {
      color: var(--accent-color);
      margin-bottom: 20px;
    }

    #instructions ul {
      text-align: left;
      max-width: 500px;
      margin: 20px auto;
      line-height: 1.6;
    }

    #instructions li {
      margin-bottom: 10px;
    }

    .close-btn {
      margin-top: 30px;
      background: var(--secondary-color);
      color: white;
      padding: 10px 25px;
      border-radius: 50px;
    }

    .garbage-line {
      background: rgba(255, 255, 255, 0.2);
      border: 1px dashed rgba(255, 255, 255, 0.5);
    }

    .player-controls {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 15px;
    }

    .player-controls h3 {
      font-size: 1rem;
      color: var(--accent-color);
      text-align: center;
    }

    @media (max-width: 1024px) {
      .players-container {
        flex-direction: column;
      }
      
      .game-board {
        grid-template-columns: repeat(10, min(4vw, 25px));
        grid-template-rows: repeat(20, min(4vw, 25px));
      }
      
      .hold-board, .next-board {
        grid-template-columns: repeat(4, min(4vw, 25px));
        grid-template-rows: repeat(4, min(4vw, 25px));
      }
    }

    @media (max-width: 768px) {
      #game-area {
        flex-direction: column;
        align-items: center;
      }
      
      .side-panel {
        flex-direction: row;
        width: 100%;
        justify-content: space-around;
      }
      
      #controls {
        display: none;
      }
      
      .mobile-controls {
        display: grid;
      }
      
      .game-header {
        flex-direction: column;
        gap: 10px;
        align-items: center;
      }
    }

    @media (max-height: 700px) {
      .game-board {
        grid-template-columns: repeat(10, min(3.5vh, 25px));
        grid-template-rows: repeat(20, min(3.5vh, 25px));
      }
      
      .hold-board, .next-board {
        grid-template-columns: repeat(4, min(3.5vh, 25px));
        grid-template-rows: repeat(4, min(3.5vh, 25px));
      }
    }

    /* Animations */
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }

    .pulse {
      animation: pulse 0.5s ease;
    }

    .clear-row {
      animation: clearAnimation 0.3s ease-out;
    }

    @keyframes clearAnimation {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.1); opacity: 0.8; }
      100% { transform: scale(0); opacity: 0; }
    }
  </style>
</head>
<body>
  <div id="game-container">
    <button class="how-to-play" onclick="showInstructions()">?</button>
    
    <h1 class="game-title">2-Player Tetris Challenge</h1>
    
    <div class="players-container">
      <!-- Player 1 -->
      <div class="player-area player1">
        <div class="player-header">
          <div class="player-info">
            <div class="player-label">PLAYER 1</div>
            <div id="player1-score" class="player-value">0</div>
          </div>
          <div class="player-info">
            <div class="player-label">LEVEL</div>
            <div id="player1-level" class="player-value">1</div>
          </div>
          <div class="player-info">
            <div class="player-label">LINES</div>
            <div id="player1-lines" class="player-value">0</div>
          </div>
        </div>
        
        <div id="game-area">
          <div class="game-board-container">
            <div id="player1-board" class="game-board"></div>
          </div>
          <div class="side-panel">
            <div class="panel-box">
              <div class="panel-label">HOLD</div>
              <div id="player1-hold-board" class="hold-board"></div>
            </div>
            <div class="panel-box">
              <div class="panel-label">NEXT</div>
              <div id="player1-next-board" class="next-board"></div>
            </div>
          </div>
        </div>
        
        <div class="player-controls">
          <h3>Player 1 Controls</h3>
          <div class="mobile-controls">
            <button onclick="movePiece(0, -1, 0)" class="mobile-btn secondary">←</button>
            <button onclick="movePiece(0, 0, 1)" class="mobile-btn">↓</button>
            <button onclick="movePiece(0, 1, 0)" class="mobile-btn secondary">→</button>
            <button onclick="rotatePiece(0)" class="mobile-btn rotate secondary">ROTATE</button>
            <button onclick="dropPiece(0)" class="mobile-btn danger">DROP</button>
            <button onclick="storePiece(0)" class="mobile-btn secondary">HOLD</button>
          </div>
        </div>
      </div>
      
      <!-- Player 2 -->
      <div class="player-area player2">
        <div class="player-header">
          <div class="player-info">
            <div class="player-label">PLAYER 2</div>
            <div id="player2-score" class="player-value">0</div>
          </div>
          <div class="player-info">
            <div class="player-label">LEVEL</div>
            <div id="player2-level" class="player-value">1</div>
          </div>
          <div class="player-info">
            <div class="player-label">LINES</div>
            <div id="player2-lines" class="player-value">0</div>
          </div>
        </div>
        
        <div id="game-area">
          <div class="game-board-container">
            <div id="player2-board" class="game-board"></div>
          </div>
          <div class="side-panel">
            <div class="panel-box">
              <div class="panel-label">HOLD</div>
              <div id="player2-hold-board" class="hold-board"></div>
            </div>
            <div class="panel-box">
              <div class="panel-label">NEXT</div>
              <div id="player2-next-board" class="next-board"></div>
            </div>
          </div>
        </div>
        
        <div class="player-controls">
          <h3>Player 2 Controls</h3>
          <div class="mobile-controls">
            <button onclick="movePiece(1, -1, 0)" class="mobile-btn secondary">←</button>
            <button onclick="movePiece(1, 0, 1)" class="mobile-btn">↓</button>
            <button onclick="movePiece(1, 1, 0)" class="mobile-btn secondary">→</button>
            <button onclick="rotatePiece(1)" class="mobile-btn rotate secondary">ROTATE</button>
            <button onclick="dropPiece(1)" class="mobile-btn danger">DROP</button>
            <button onclick="storePiece(1)" class="mobile-btn secondary">HOLD</button>
          </div>
        </div>
      </div>
    </div>
    
    <div id="controls">
      <button onclick="togglePause()" class="secondary">PAUSE ⏸</button>
    </div>
    
    <div id="pause-screen">
      <h2>PAUSED</h2>
      <button onclick="togglePause()" class="restart-btn">RESUME</button>
    </div>
  </div>
  
  <div id="game-over">
    <h2>GAME OVER</h2>
    <div id="winner"></div>
    <button onclick="restartGame()" class="restart-btn">PLAY AGAIN</button>
  </div>
  
  <div id="instructions">
    <h2>HOW TO PLAY 2-PLAYER TETRIS</h2>
    <h3>Player 1 Controls</h3>
    <ul>
      <li><strong>A/D</strong> Move piece left/right</li>
      <li><strong>S</strong> Soft drop (move down)</li>
      <li><strong>W</strong> Rotate piece</li>
      <li><strong>SPACE</strong> Hard drop</li>
      <li><strong>C</strong> Hold piece</li>
    </ul>
    <h3>Player 2 Controls</h3>
    <ul>
      <li><strong>← →</strong> Move piece left/right</li>
      <li><strong>↓</strong> Soft drop (move down)</li>
      <li><strong>↑</strong> Rotate piece</li>
      <li><strong>ENTER</strong> Hard drop</li>
      <li><strong>SHIFT</strong> Hold piece</li>
    </ul>
    <p>Complete lines to score points and send garbage lines to your opponent!</p>
    <button onclick="hideInstructions()" class="close-btn">GOT IT!</button>
  </div>

  <script>
    // Game constants
    const BOARD_WIDTH = 10;
    const BOARD_HEIGHT = 20;
    const PLAYER_COUNT = 2;

    // Game state for both players
    const players = [
      {
        board: Array.from({ length: BOARD_HEIGHT }, () => Array(BOARD_WIDTH).fill(0)),
        currentPiece: null,
        nextPiece: null,
        storedPiece: null,
        canStorePiece: true,
        score: 0,
        level: 1,
        lines: 0,
        dropInterval: 1000,
        lastTime: 0,
        isGameOver: false
      },
      {
        board: Array.from({ length: BOARD_HEIGHT }, () => Array(BOARD_WIDTH).fill(0)),
        currentPiece: null,
        nextPiece: null,
        storedPiece: null,
        canStorePiece: true,
        score: 0,
        level: 1,
        lines: 0,
        dropInterval: 1000,
        lastTime: 0,
        isGameOver: false
      }
    ];

    let isPaused = false;
    let animationFrameId;
    let garbageQueue = [0, 0]; // Garbage lines to be sent to each player

    const tetrominoes = [
      { shape: [[1, 1, 1, 1]], color: 'I' }, // I
      { shape: [[1, 1], [1, 1]], color: 'O' }, // O
      { shape: [[0, 1, 0], [1, 1, 1]], color: 'T' }, // T
      { shape: [[1, 1, 0], [0, 1, 1]], color: 'S' }, // S
      { shape: [[0, 1, 1], [1, 1, 0]], color: 'Z' }, // Z
      { shape: [[1, 0, 0], [1, 1, 1]], color: 'J' }, // J
      { shape: [[0, 0, 1], [1, 1, 1]], color: 'L' }  // L
    ];

    // Create a new piece
    function createPiece() {
      const piece = tetrominoes[Math.floor(Math.random() * tetrominoes.length)];
      return {
        shape: piece.shape.map(row => [...row]),
        color: piece.color,
        x: Math.floor((BOARD_WIDTH - piece.shape[0].length) / 2),
        y: 0
      };
    }

    // Get ghost position for a piece
    function getGhostPosition(playerIndex) {
      const player = players[playerIndex];
      const ghost = { ...player.currentPiece, y: player.currentPiece.y };
      
      while (!isCollision(playerIndex, ghost)) {
        ghost.y++;
      }
      ghost.y--;
      
      return ghost;
    }

    // Draw the game board for a player
    function drawBoard(playerIndex) {
      const boardElement = document.getElementById(`player${playerIndex + 1}-board`);
      boardElement.innerHTML = '';
      
      const player = players[playerIndex];
      const ghost = getGhostPosition(playerIndex);
      
      for (let y = 0; y < BOARD_HEIGHT; y++) {
        for (let x = 0; x < BOARD_WIDTH; x++) {
          const cell = document.createElement('div');
          cell.classList.add('cell');
          
          const isPlaced = player.board[y][x];
          const isCurrent = player.currentPiece && 
                           player.currentPiece.shape[y - player.currentPiece.y]?.[x - player.currentPiece.x];
          const isGhost = ghost && 
                         ghost.shape[y - ghost.y]?.[x - ghost.x];
          
          if (isPlaced) {
            cell.style.backgroundColor = getColor(isPlaced);
            cell.classList.add('tetromino');
            cell.classList.add(isPlaced);
          } else if (isGhost && !isCurrent) {
            cell.style.backgroundColor = getColor(player.currentPiece.color);
            cell.classList.add('ghost');
          } else if (isCurrent) {
            cell.style.backgroundColor = getColor(player.currentPiece.color);
            cell.classList.add('tetromino');
            cell.classList.add(player.currentPiece.color);
          }
          
          boardElement.appendChild(cell);
        }
      }
    }

    // Get color for a tetromino type
    function getColor(type) {
      switch(type) {
        case 'I': return '#00C2D1';
        case 'J': return '#FF6B6B';
        case 'L': return '#FFA630';
        case 'O': return '#FFE66D';
        case 'S': return '#4ECDC4';
        case 'T': return '#9D6BFF';
        case 'Z': return '#FF85A1';
        default: return '#FFFFFF';
      }
    }

    // Draw the hold board for a player
    function drawHoldBoard(playerIndex) {
      const holdBoard = document.getElementById(`player${playerIndex + 1}-hold-board`);
      holdBoard.innerHTML = '';
      
      const player = players[playerIndex];
      
      for (let y = 0; y < 4; y++) {
        for (let x = 0; x < 4; x++) {
          const cell = document.createElement('div');
          cell.classList.add('cell');
          
          if (player.storedPiece && player.storedPiece.shape[y]?.[x]) {
            cell.style.backgroundColor = getColor(player.storedPiece.color);
            cell.classList.add('tetromino');
            cell.classList.add(player.storedPiece.color);
          }
          
          holdBoard.appendChild(cell);
        }
      }
    }

    // Draw the next board for a player
    function drawNextBoard(playerIndex) {
      const nextBoard = document.getElementById(`player${playerIndex + 1}-next-board`);
      nextBoard.innerHTML = '';
      
      const player = players[playerIndex];
      
      for (let y = 0; y < 4; y++) {
        for (let x = 0; x < 4; x++) {
          const cell = document.createElement('div');
          cell.classList.add('cell');
          
          if (player.nextPiece.shape[y]?.[x]) {
            cell.style.backgroundColor = getColor(player.nextPiece.color);
            cell.classList.add('tetromino');
            cell.classList.add(player.nextPiece.color);
          }
          
          nextBoard.appendChild(cell);
        }
      }
    }

    // Move a piece for a player
    function movePiece(playerIndex, dx, dy) {
      if (isPaused || players[playerIndex].isGameOver) return;
      
      const player = players[playerIndex];
      player.currentPiece.x += dx;
      player.currentPiece.y += dy;
      
      if (isCollision(playerIndex)) {
        player.currentPiece.x -= dx;
        player.currentPiece.y -= dy;
        
        if (dy === 1) {
          placePiece(playerIndex);
          clearLines(playerIndex);
          player.currentPiece = player.nextPiece;
          player.nextPiece = createPiece();
          player.canStorePiece = true;
          drawNextBoard(playerIndex);
          
          if (isCollision(playerIndex)) {
            player.isGameOver = true;
            checkGameOver();
          }
        }
      }
      
      drawBoard(playerIndex);
    }

    // Rotate a piece for a player
    function rotatePiece(playerIndex) {
      if (isPaused || players[playerIndex].isGameOver) return;
      
      const player = players[playerIndex];
      const rotated = player.currentPiece.shape[0].map((_, i) =>
        player.currentPiece.shape.map(row => row[i]).reverse()
      );
      
      const originalShape = player.currentPiece.shape;
      player.currentPiece.shape = rotated;
      
      if (isCollision(playerIndex)) {
        player.currentPiece.shape = originalShape;
      }
      
      drawBoard(playerIndex);
    }

    // Check for collision
    function isCollision(playerIndex, piece = players[playerIndex].currentPiece) {
      const player = players[playerIndex];
      
      return piece.shape.some((row, y) =>
        row.some((value, x) => {
          const boardY = piece.y + y;
          const boardX = piece.x + x;
          
          return (value && (
            boardY >= BOARD_HEIGHT ||
            boardX < 0 ||
            boardX >= BOARD_WIDTH ||
            (boardY >= 0 && player.board[boardY][boardX])
          ));
        })
      );
    }

    // Place a piece on the board
    function placePiece(playerIndex) {
      const player = players[playerIndex];
      
      player.currentPiece.shape.forEach((row, y) => {
        row.forEach((value, x) => {
          if (value) {
            const boardY = player.currentPiece.y + y;
            const boardX = player.currentPiece.x + x;
            
            if (boardY >= 0 && boardY < BOARD_HEIGHT && boardX >= 0 && boardX < BOARD_WIDTH) {
              player.board[boardY][boardX] = player.currentPiece.color;
            }
          }
        });
      });
    }

    // Clear completed lines and send garbage
    function clearLines(playerIndex) {
      const player = players[playerIndex];
      let linesCleared = 0;
      
      for (let y = BOARD_HEIGHT - 1; y >= 0; y--) {
        if (player.board[y].every(cell => cell)) {
          player.board.splice(y, 1);
          player.board.unshift(Array(BOARD_WIDTH).fill(0));
          linesCleared++;
          y++;
        }
      }
      
      if (linesCleared > 0) {
        // Update score and level
        player.score += linesCleared * 100 * player.level;
        player.lines += linesCleared;
        
        document.getElementById(`player${playerIndex + 1}-score`).textContent = player.score;
        document.getElementById(`player${playerIndex + 1}-lines`).textContent = player.lines;
        
        // Level up every 10 lines
        if (player.lines >= player.level * 10) {
          player.level++;
          player.dropInterval = Math.max(100, 1000 - (player.level - 1) * 100);
          document.getElementById(`player${playerIndex + 1}-level`).textContent = player.level;
        }
        
        // Send garbage to opponent
        const opponentIndex = (playerIndex + 1) % PLAYER_COUNT;
        garbageQueue[opponentIndex] += linesCleared;
        
        // Add garbage lines to opponent
        if (garbageQueue[opponentIndex] > 0) {
          addGarbageLines(opponentIndex, garbageQueue[opponentIndex]);
          garbageQueue[opponentIndex] = 0;
        }
      }
    }

    // Add garbage lines to a player's board
    function addGarbageLines(playerIndex, lines) {
      const player = players[playerIndex];
      
      for (let i = 0; i < lines; i++) {
        // Remove the top line
        player.board.shift();
        
        // Create a new garbage line with one hole
        const holePos = Math.floor(Math.random() * BOARD_WIDTH);
        const newLine = Array(BOARD_WIDTH).fill('G');
        newLine[holePos] = 0;
        
        // Add the garbage line at the bottom
        player.board.push(newLine);
      }
      
      drawBoard(playerIndex);
    }

    // Hard drop for a player
    function dropPiece(playerIndex) {
      if (isPaused || players[playerIndex].isGameOver) return;
      
      const player = players[playerIndex];
      
      while (!isCollision(playerIndex)) {
        player.currentPiece.y++;
      }
      
      player.currentPiece.y--;
      placePiece(playerIndex);
      clearLines(playerIndex);
      player.currentPiece = player.nextPiece;
      player.nextPiece = createPiece();
      player.canStorePiece = true;
      drawNextBoard(playerIndex);
      
      if (isCollision(playerIndex)) {
        player.isGameOver = true;
        checkGameOver();
      }
      
      drawBoard(playerIndex);
    }

    // Store a piece for a player
    function storePiece(playerIndex) {
      if (isPaused || players[playerIndex].isGameOver || !players[playerIndex].canStorePiece) return;
      
      const player = players[playerIndex];
      
      if (player.storedPiece) {
        const temp = player.storedPiece;
        player.storedPiece = { 
          shape: player.currentPiece.shape.map(row => [...row]), 
          color: player.currentPiece.color 
        };
        player.currentPiece = { 
          ...temp, 
          x: Math.floor((BOARD_WIDTH - temp.shape[0].length) / 2), 
          y: 0 
        };
      } else {
        player.storedPiece = { 
          shape: player.currentPiece.shape.map(row => [...row]), 
          color: player.currentPiece.color 
        };
        player.currentPiece = player.nextPiece;
        player.nextPiece = createPiece();
        drawNextBoard(playerIndex);
      }
      
      player.canStorePiece = false;
      drawHoldBoard(playerIndex);
      drawBoard(playerIndex);
    }

    // Toggle pause state
    function togglePause() {
      isPaused = !isPaused;
      
      if (!isPaused) {
        players.forEach((player, index) => {
          player.lastTime = performance.now();
        });
        gameLoop(performance.now());
      }
    }

    // Check if the game is over
    function checkGameOver() {
      const gameOverCount = players.filter(player => player.isGameOver).length;
      
      if (gameOverCount === PLAYER_COUNT) {
        endGame();
      }
    }

    // End the game
    function endGame() {
      cancelAnimationFrame(animationFrameId);
      
      // Determine winner
      let winnerText = "It's a tie!";
      if (players[0].score > players[1].score) {
        winnerText = "Player 1 Wins!";
      } else if (players[1].score > players[0].score) {
        winnerText = "Player 2 Wins!";
      }
      
      document.getElementById('winner').textContent = winnerText;
      document.getElementById('game-over').style.display = 'flex';
    }

    // Restart the game
    function restartGame() {
      players.forEach((player, index) => {
        player.board = Array.from({ length: BOARD_HEIGHT }, () => Array(BOARD_WIDTH).fill(0));
        player.score = 0;
        player.level = 1;
        player.lines = 0;
        player.storedPiece = null;
        player.canStorePiece = true;
        player.isGameOver = false;
        player.dropInterval = 1000;
        
        document.getElementById(`player${index + 1}-score`).textContent = player.score;
        document.getElementById(`player${index + 1}-level`).textContent = player.level;
        document.getElementById(`player${index + 1}-lines`).textContent = player.lines;
        
        drawHoldBoard(index);
        
        if (index === 0) {
          player.currentPiece = createPiece();
          player.nextPiece = createPiece();
        } else {
          player.currentPiece = createPiece();
          player.nextPiece = createPiece();
        }
        
        drawNextBoard(index);
        drawBoard(index);
      });
      
      garbageQueue = [0, 0];
      isPaused = false;
      document.getElementById('game-over').style.display = 'none';
      
      players.forEach((player, index) => {
        player.lastTime = performance.now();
      });
      
      gameLoop(performance.now());
    }

    // Game loop
    function gameLoop(time) {
      if (isPaused) return;
      
      players.forEach((player, index) => {
        if (!player.isGameOver) {
          const delta = time - player.lastTime;
          
          if (delta >= player.dropInterval) {
            movePiece(index, 0, 1);
            player.lastTime = time - (delta % player.dropInterval);
          }
        }
      });
      
      animationFrameId = requestAnimationFrame(gameLoop);
    }

    // Show instructions
    function showInstructions() {
      document.getElementById('instructions').style.display = 'flex';
    }

    // Hide instructions
    function hideInstructions() {
      document.getElementById('instructions').style.display = 'none';
    }

    // Keyboard controls
    document.addEventListener('keydown', (e) => {
      if (e.key === 'p' || e.key === 'P') {
        togglePause();
        return;
      }
      
      // Player 1 controls (WASD + Space + C)
      if (e.key === 'a' || e.key === 'A') movePiece(0, -1, 0);
      if (e.key === 'd' || e.key === 'D') movePiece(0, 1, 0);
      if (e.key === 's' || e.key === 'S') movePiece(0, 0, 1);
      if (e.key === 'w' || e.key === 'W') rotatePiece(0);
      if (e.key === ' ') dropPiece(0);
      if (e.key === 'c' || e.key === 'C') storePiece(0);
      
      // Player 2 controls (Arrow keys + Enter + Shift)
      if (e.key === 'ArrowLeft') movePiece(1, -1, 0);
      if (e.key === 'ArrowRight') movePiece(1, 1, 0);
      if (e.key === 'ArrowDown') movePiece(1, 0, 1);
      if (e.key === 'ArrowUp') rotatePiece(1);
      if (e.key === 'Enter') dropPiece(1);
      if (e.key === 'Shift') storePiece(1);
    });

    // Initialize the game
    function startGame() {
      players.forEach((player, index) => {
        player.currentPiece = createPiece();
        player.nextPiece = createPiece();
        drawNextBoard(index);
        drawBoard(index);
        player.lastTime = performance.now();
      });
      
      gameLoop(performance.now());
    }

    // Start the game
    startGame();
  </script>
</body>
</html>
